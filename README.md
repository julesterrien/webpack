# WHY
Server-side templating (old model) vs. single page app (new model)
Single page apps = a ton of JS to compile to render the HTML efficiently
More JS = long JS files = hard to manage = how to we organize = split in code in various modules
More modules = more dependencies = in which order will they be executed? Load order becomes key

**Webpack merges many different JS files, figures out the load order and outputs a single bundled file that can be loaded on the DOM quickly**

How do different JS modules connect to each other to enable dependencies? using a import/export syntax
There are different ways to import/export:
- Common.js: require & module.exports
- ES2015: import/export

How does webpack affect import/exports?
- it wraps each module it in a function
- adds each function to an array
- calls the different functions in that array of wrapped modules
This allows the tool to selectively call different modules based on when they're needed/required


# GETTING STARTED
install webpack:
npm i webpack --save-dev
add a script "build": "webpack" to have future developers use the locally installed version when building

touch webpack.config.js to create a config file
entry: the 'root' of our application (the file at the top of the dependency tree)
output: path & filename (where should webpack's bundle go and what should it be called)

# LOADERS

Webpack makes heavy use of loaders to pre or post process different files/file-types

For eg. Babel:
turns ES15 code in ES5

Use:
- babel-loader: teaches babel how to work with webpack
- babel-core: takes in code, parses it, and generates an output file
- babel-preset-env: ruleset to turn ES2015/6/7 code in ES5
npm install these
add babel to webpack.config.js array of rules
create a .babelrc file to manage babel's config, which presets to use, etc
```
"presets": [
  // ES15 to ES5 transpilation
  "babel-preset-env",
  // JSX transpilation -- goes with npm babel-preset-react
  "react"
]
```

at this point, running 'npm run build' again will update the bundle file and you will see that ES6 code will have been tranpiled

### Useful loaders:

- css-loader:
...A loader to deal with css imports
...Takes css imports within different modules and adds them to the html document by passing the css as a string to webpack's bundle

- style-loader:
...A loader to add styles to html
...Takes modules inside the bundle that have css (given by css loader) and injects that css into the DOM (in the head tag) after the page has loaded
...The only drawback with this is that you add css directly into the HTML as separate files...it would be faster to combine all css files into one...

- extract-text-webpack-plugin:
...Used to combine all css strings into one file that can then inserted into the DOM
...Takes a reference to a loader, runs webpack with it, take any text generated by that loader and saves it to a single file in the output directory

- webpack-image-loader:
...compresses image files

- url-loader:
...moves images from assets to build
...if given a publicPath, it will preprend it to the relevant import statements it finds
...can have specific options:
..-if images are small, include them inside the bundle.js file
..-if the images are big, include them in the build directory

npm install these
add them to webpack.config rules

# CODE SPLITTING
Split code in different files and programatically decide which files to load

To load modules programatically, use:
```
System.import('./fileName').then(module => {
  // do something with the imported module
  // module.default()
})
```
When webpack notices System.import, it adds some logic to only add modules on specific requests

# REDUCING BUNDLE SIZE

1. code splitting
Your code vs. vendor code
Put you code in bundle.js: needs to be small as will change (be re-uploaded into the DOM) frequently
Put vendor code in vendor.js: can be large because will just be loaded once then cached until next npm upgrades
To do that, use webpack.config to add two entry points (bundle, vendor) and allow for multiple outputs
And use commongChunksPlugin to tell webpack to remove files that are in vendor from bundle

To have these different JS outputs run, we need to add them to the HTML.
html-webpack-plugin does that automatically
add it to webpack.config

To disable cache in dev mode, go to chrome dev tools settings and activate 'Disable cache (while DevTools is open)'
users won't have that activated however so we need to tell the browser to use a new version of the bundle
each time it gets changed
for that, use 'chunk hashing' by adding a hash id to the bundle name
with that option on in config, new output files will be created each time we build and each time files have changed

To only keep new output files and not get a huge build folder with every version, write a script to 'clean'
"clean": "rimraf dist"
rimraf makes sure bash commands work both on linux/windows
this will delete up the dist directory

https://webpack.github.io/docs/code-splitting.html


**Example of code splitting with react Router:**
```
const componentRoutes = {
  component: Home,
  path: '/',
  indexRoute: { component: ArtistMain },
  childRoutes: [
    {
      path: 'artist/new',
      getComponent(location, cb) {
        System.import('./components/artists/ArtistCreate')
          .then(module => cb(null, module.default));
      }
    }
  ]
}
const Routes = () => {
  return (
    <Router history={hasHistory} routes={componentRoutes} />
  )
}
```


# WEBPACK DEV SERVER VS. NODE SERVER

Webpack Dev server & node server
Acts as a middleman between the output and the browser
Takes care of hot loading

npm i webpack-dev-server@2.0.0-rc0
add a script "serve": "webpack-dev-server"
running webpack-dev-server will build the project in memory (not on hard disk): so can run the app even though a build folder hasn't been created

# PRODUCTION

Use DefinePlugin to define window-scope variables in the output file
For eg:
```
new webpack.DefinePlugin({
  'process.env.NODE_ENV': json.stringify(process.end.NODE_ENV)
})
```
Change build script to include correct NODE_ENV
and add **'-p'** to tell webpack to run in prod mode (minimizes & uglifies JS code)
"build": "NODE_ENV=production npm run clean && webpack -p"

In prod, serve directly from the built dist
In dev mode, use a webpack middleware to serve webpack bundle: webpack-dev-middleware
In server.js:
```
if (process.env.NODE_ENV !== 'production') {
  const webpackMiddleware = require('webpack-dev-middleware')
  const webpack = require('webpack')
  const webpackConfig = require('./webpack.config.js')
  app.use(webpackMiddleware(webpack(webpackConfig)))
} else {
  app.use(express.static('dist'))
  // this also helps react router avoid the browser history bug on 'return'
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist/index.html'));
  })
}
```
